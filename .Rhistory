X.100 <- seq(0,1,length.out=100)
X.1000 <- seq(0,1,length.out=1000)
create.samples <- function(n) {
if (n==30) {
the.sequence <- SEQ.30
}
if (n==100) {
the.sequence <- SEQ.100
}
if (n==1000) {
the.sequence <- SEQ.1000
}
return(sample(the.sequence,N.BOOTS*n,replace = T))
}
sample.index.30 <-   matrix(create.samples(30),  nrow=1,ncol=30*N.BOOTS)
sample.index.100 <-  matrix(create.samples(100), nrow=1,ncol=100*N.BOOTS)
sample.index.1000 <- matrix(create.samples(1000),nrow=1,ncol=1000*N.BOOTS)
#X <- matrix(rep(x,N.BOOTS),byrow=T,nrow=N.BOOTS)
# profvis is for profiling (timing)
#profvis({
#t <- doCalculations(population,phi,n,b,N)
## Get true population.
##
getY <- function(phi,population,n,mu,mn,nu) {
y <- rep(0,n)
while (sum(y) == 0) {
# get a sample, until we get one, which is not all zeros.
if (phi==1) {
y<-rpois(n,mu) }
else {
if (population == "Negbin") {
y<-rnegbin(n,mu,mn)
}
if (population == 'Neyman') {
y<-rpois(n,rpois(n,mn)*nu)
}
if (population == 'Poisson lognormal') {
y<-rpois(n,rpois(n,mn)*nu)
}
}
}
return(y)
}
# function to fit Poisson model, used in bootstraps
#   y.x is a vector of both the observations y and
#   the predictors x. First come the y's, then the x's.
#
#
fitit <- function(y.x,df,n) {
model <- glm(y.x[1:n]~y.x[(n+1):(2*n)],family="poisson")
phihat <- calcPhihat(fitted(model),y.x[1:n],df)
return(data.frame(phihat))
}
calcPhihat <- function(muhat,y,df) {
P <-sum((y-muhat)^2/muhat)
sbar<-mean((y-muhat)/muhat)
phihat<-(P/df)/(1+sbar)
}
###################################################
#
# doCalculations
#
# Computes everything for 1 combination of population, phi,
#   sample size (n), beta, number of simulations (N)
#
# Returns:
doCalculations <- function(population,phi,n,b1,b2,N) {
sample.index <- NA
if (n==30) {
#sequ=SEQ.30
x <- X.30
sample.index <- sample.index.30
}
if (n==100) {
#sequ=SEQ.100
x <- X.100
sample.index <- sample.index.100
}
if (n==1000) {
#sequ=SEQ.1000
x <- X.1000
sample.index <- sample.index.1000
}
# skip duplicates: For phi=1, the true population
#   is always Poisson.
if (phi==1) {
if (population != 'Negbin') {
return(NA)
}
}
parms <- c(population,phi,n,b1,b2,N)
#print(parms)
beta<-c(b1,b2)
p<-length(beta)
eta<-beta[1]+beta[2]*x
mu<-exp(eta)
nu <- phi-1
mn<-mu/nu
w<-(mn+1)/mn
mx<-log(mu)-0.5*log(w)
sx<-sqrt(log(w))
## vectors to hold CIs
{
boots.phi.int <- vector()
phi.low <- vector()
phi.upp <- vector()
phi.err <- vector()
beta.low <- vector()
beta.upp <- vector()
beta.err <- vector()
}
#isInInterval(2,c(1,3))
isInInterval <- function(value,interval) {
return(value > interval[1] & value < interval[2])
}
#
# Start simulations
#
for (sim in 1:N) {
# show heartbeat
if (sim %% 500 == 0) { print(sim) }
print(sim)
# set true population
y <- getY(phi,population,n,mu,mn,nu)
# fit Poisson model
model <- glm(y~x,family="poisson")
muhat<-fitted(model)
P<-sum((y-muhat)^2/muhat)
sbar<-mean((y-muhat)/muhat)
phihat<-(P/(n-p))/(1+sbar)
df <- n-p
coef.x <- summary(model)$coefficients[2,1]
coef.se <- summary(model)$coefficients[2,2]
##
## Bootstrap
##
do.bootstrap <- F
if (do.bootstrap == T) {
ss <- matrix(
data=y[sample.index],byrow=T,nrow=N.BOOTS,ncol=n)
preds <- matrix(
data=x[sample.index],byrow=T,nrow=N.BOOTS,ncol=n)
# apply poisson model to each row (ie. each bootstrap)
phihat.boots <- unlist(apply(cbind(ss,preds),1,fitit,df,n))
# 05/12/19 keeping CI for phi bootstrap, as opposed to CI for beta
boots.phi.int <- phihat^2  / quantile(phihat.boots,c(ALPHA_UPPER,ALPHA_LOWER))
ts <- rnorm(N.BOOTS) * sqrt(phihat/phihat.boots)
# get t-values
t.low <- quantile(ts,ALPHA_LOWER)
t.upp <- quantile(ts,ALPHA_UPPER)
# ci for beta
beta.low[sim] <- coef.x - t.upp * sqrt(phihat) * coef.se
beta.upp[sim] <- coef.x - t.low * sqrt(phihat) * coef.se
beta.err[sim] <- !isInInterval(beta[2],c(beta.low[sim],beta.upp[sim]))
# ci for phi
phi.low[sim] <- boots.phi.int[1]
phi.upp[sim] <- boots.phi.int[2]
phi.err[sim] <- !isInInterval(phi,c(phi.low[sim],phi.upp[sim]))
}
}
##
## end of simulations
##
# combine coverage rates
#
error.phi <- sum(phi.err)/N
error.beta <- sum(beta.err,na.rm=T)/length(which(!is.na(beta.err)))
# convert error rates to coverage
result.coverage <- c(1-error.phi,1-error.beta)
# combine power calculations
#
phi.power <- calcExcludesValue(1,phi.low,phi.upp)
beta.power <- calcExcludesValue(0,beta.low,beta.upp)
result.power <- c(phi.power,beta.power)
# combine CI median widths
#
phi.width <- calcMedianWidth(phi.low,phi.upp)
beta.width <- calcMedianWidth(beta.low,beta.upp)
result.width <- c(phi.width,beta.width)
# gather the rates of NAs, ie. the rate of the method not working
beta.na <- length(which(is.na(beta.err)))/N
result.na <- c(beta.na)
# combine all results. This one will go to the csv file.
result <- c(parms,result.coverage,result.power,result.width,result.na)
return(result)
}
###################################################
##
## end of doCalculations
##
###################################################
# profis })
print('started')
print(Sys.time())
set.seed(10)
N <- 10
#betas <- rbind(c(-3,3),c(0.1,2.2),c(2.3,0.7))
phis <- c(1,3,5)
pops <- c("Negbin" ,"Neyman","Poisson lognormal")
beta1 <- c(-3,0.1,2.3)
ns <-  c(30,100)
combs <- expand.grid(phis,pops,beta1,ns)
colnames(combs) <- c('phi','pop','beta1','n')
combs$beta2 <- NA
combs[which(combs$beta1==-3),'beta2'] <- 3
combs[which(combs$beta1==0.1),'beta2'] <- 2.2
combs[which(combs$beta1==2.3),'beta2'] <-0.7
combs
# All calculations, for writing to csv file. This will be
#   vector of strings: Each line is the comma separated results for
#   one set of parameters (population,phi,n,beta)
calcs <- foreach(i=1:dim(combs)[1], .combine = rbind, .packages=c('MASS','purrr'))  %dopar% {
doCalculations(population = combs$pop[i],
phi= combs$phi[i],
n = combs$n[i],
b1 = combs$beta1[i],
b2 = combs$beta2[i],
N = N)
}
write.csv(calcs,'results-mainpar9b.csv',row.names=F,quote=F)
print('finished')
print(Sys.time())
calcs[1,]
population = combs$pop[i]
i = 1
population = combs$pop[i]
phi= combs$phi[i]
n = combs$n[i]
b1 = combs$beta1[i]
b2 = combs$beta2[i]
N = N
combs
head(combs)
population
sample.index <- NA
if (n==30) {
#sequ=SEQ.30
x <- X.30
sample.index <- sample.index.30
}
if (n==100) {
#sequ=SEQ.100
x <- X.100
sample.index <- sample.index.100
}
if (n==1000) {
#sequ=SEQ.1000
x <- X.1000
sample.index <- sample.index.1000
}
# skip duplicates: For phi=1, the true population
#   is always Poisson.
if (phi==1) {
if (population != 'Negbin') {
return(NA)
}
}
parms <- c(population,phi,n,b1,b2,N)
beta<-c(b1,b2)
p<-length(beta)
eta<-beta[1]+beta[2]*x
mu<-exp(eta)
nu <- phi-1
mn<-mu/nu
w<-(mn+1)/mn
mx<-log(mu)-0.5*log(w)
sx<-sqrt(log(w))
## vectors to hold CIs
{
boots.phi.int <- vector()
phi.low <- vector()
phi.upp <- vector()
phi.err <- vector()
beta.low <- vector()
beta.upp <- vector()
beta.err <- vector()
}
#isInInterval(2,c(1,3))
isInInterval <- function(value,interval) {
return(value > interval[1] & value < interval[2])
}
#
# Start simulations
#
for (sim in 1:N) {
# show heartbeat
if (sim %% 500 == 0) { print(sim) }
print(sim)
# set true population
y <- getY(phi,population,n,mu,mn,nu)
# fit Poisson model
model <- glm(y~x,family="poisson")
muhat<-fitted(model)
P<-sum((y-muhat)^2/muhat)
sbar<-mean((y-muhat)/muhat)
phihat<-(P/(n-p))/(1+sbar)
df <- n-p
coef.x <- summary(model)$coefficients[2,1]
coef.se <- summary(model)$coefficients[2,2]
##
## Bootstrap
##
do.bootstrap <- F
if (do.bootstrap == T) {
ss <- matrix(
data=y[sample.index],byrow=T,nrow=N.BOOTS,ncol=n)
preds <- matrix(
data=x[sample.index],byrow=T,nrow=N.BOOTS,ncol=n)
# apply poisson model to each row (ie. each bootstrap)
phihat.boots <- unlist(apply(cbind(ss,preds),1,fitit,df,n))
# 05/12/19 keeping CI for phi bootstrap, as opposed to CI for beta
boots.phi.int <- phihat^2  / quantile(phihat.boots,c(ALPHA_UPPER,ALPHA_LOWER))
ts <- rnorm(N.BOOTS) * sqrt(phihat/phihat.boots)
# get t-values
t.low <- quantile(ts,ALPHA_LOWER)
t.upp <- quantile(ts,ALPHA_UPPER)
# ci for beta
beta.low[sim] <- coef.x - t.upp * sqrt(phihat) * coef.se
beta.upp[sim] <- coef.x - t.low * sqrt(phihat) * coef.se
beta.err[sim] <- !isInInterval(beta[2],c(beta.low[sim],beta.upp[sim]))
# ci for phi
phi.low[sim] <- boots.phi.int[1]
phi.upp[sim] <- boots.phi.int[2]
phi.err[sim] <- !isInInterval(phi,c(phi.low[sim],phi.upp[sim]))
}
}
# combine coverage rates
#
error.phi <- sum(phi.err)/N
error.beta <- sum(beta.err,na.rm=T)/length(which(!is.na(beta.err)))
# convert error rates to coverage
result.coverage <- c(1-error.phi,1-error.beta)
# combine power calculations
#
phi.power <- calcExcludesValue(1,phi.low,phi.upp)
beta.power <- calcExcludesValue(0,beta.low,beta.upp)
result.power <- c(phi.power,beta.power)
# combine CI median widths
#
phi.width <- calcMedianWidth(phi.low,phi.upp)
beta.width <- calcMedianWidth(beta.low,beta.upp)
result.width <- c(phi.width,beta.width)
# gather the rates of NAs, ie. the rate of the method not working
beta.na <- length(which(is.na(beta.err)))/N
result.na <- c(beta.na)
# combine all results. This one will go to the csv file.
result <- c(parms,result.coverage,result.power,result.width,result.na)
result
parms
c(population,phi,n,b1,b2,N)
population
x <- factor('A','B')
c(x[1])
x
x <- factor(c('A','B'))
x[1]
parm <- c(x[1])
parm
x[1]
x[1]
c(x[1])
c(x[2])
?c
results <- read.csv('results-mainpar9.csv',
stringsAsFactors = F,header=F)
results
dim(results)
c("Population",'phi','n','b1','b2',"N",
"cover.chisq","cover.boots",
"pow.chisq","pow.boots",
"med.chisq","med.boots",
"err.chisq"
)
colnames(results)=c("Population",'phi','n','b1','b2',"N",
"cover.chisq","cover.boots",
"pow.chisq","pow.boots",
"med.chisq","med.boots",
"err.chisq"
)
head(results)
## add mu lower and upper, calculated from the betas
results$mu.lower <- NA
results$mu.upper <- NA
for (i in 1:dim(results)[1]) {
x<-seq(0,1,length.out=results$n[i])
results$mu.lower[i]  <- range(exp(results$b1[i] + results$b2[i] * x))[1]
results$mu.upper[i]  <- range(exp(results$b1[i] + results$b2[i] * x))[2]
}
i
x<-seq(0,1,length.out=results$n[i])
results$n[i]
colnames(results)=c("Population",'phi','n','b1','b2',"N",
"cover.chisq","cover.boots",
"pow.chisq","pow.boots",
"med.chisq","med.boots",
"err.chisq"
)
head(results)
for (i in 1:dim(results)[1]) {
x<-seq(0,1,length.out=results$N[i])
results$mu.lower[i]  <- range(exp(results$b1[i] + results$b2[i] * x))[1]
results$mu.upper[i]  <- range(exp(results$b1[i] + results$b2[i] * x))[2]
}
results$N[i]
head(results)
colnames(results)
results$n
results <- read.csv('results-mainpar9.csv',
stringsAsFactors = F,header=T)
results[1,]
colnames(results)=c("Population",'phi','n','b1','b2',"N",
"cover.chisq","cover.boots",
"pow.chisq","pow.boots",
"med.chisq","med.boots",
"err.chisq"
)
## add mu lower and upper, calculated from the betas
results$mu.lower <- NA
results$mu.upper <- NA
for (i in 1:dim(results)[1]) {
x<-seq(0,1,length.out=results$N[i])
results$mu.lower[i]  <- range(exp(results$b1[i] + results$b2[i] * x))[1]
results$mu.upper[i]  <- range(exp(results$b1[i] + results$b2[i] * x))[2]
}
results$N[i]
results$N
results$n
results <- read.csv('results-mainpar9.csv',
stringsAsFactors = F,header=T)
colnames(results)=c("Population",'phi','n','b1','b2',"N",
"cover.chisq","cover.boots",
"pow.chisq","pow.boots",
"med.chisq","med.boots",
"err.chisq"
)
results$N
setwd('~/overdispersion')
results <- read.csv('results-mainpar9.csv',
stringsAsFactors = F,header=T)
dim(results)
head(results)
dim(results)
results[1,]
colnames(results)=c("Population",'phi','n','b1','b2',"N",
"cover.chisq","cover.boots",
"pow.chisq","pow.boots",
"med.chisq","med.boots",
"err.chisq"
)
results$N
## drop duplicates (phi == 1)
dropm <- which(is.na(results$N))
dropm
if (length(dropm) > 0) {
results <- results[-dropm,]
}
## add mu lower and upper, calculated from the betas
results$mu.lower <- NA
results$mu.upper <- NA
for (i in 1:dim(results)[1]) {
x<-seq(0,1,length.out=results$N[i])
results$mu.lower[i]  <- range(exp(results$b1[i] + results$b2[i] * x))[1]
results$mu.upper[i]  <- range(exp(results$b1[i] + results$b2[i] * x))[2]
}
head(results)
colnames(results)=c("Population",'phi','n','b1','b2',"N",
"cover.phi","cover.beta",
"pow.phi","pow.beta",
"med.phi","med.beta",
"err"
)
head(results)
dim(results)
head(results)
results[which(results$population==1),]
colnames(results)
results[which(results$Population==1),]
results[which(results$Population==1),"Population"] <- "Negbin"
results[which(results$Population==3),"Population"] <- "Pois lognorm"
pops
results[which(results$Population==1),"Population"] <- "Negbin"
results[which(results$Population==2),"Population"] <- "Neyman"
results[which(results$Population==3),"Population"] <- "Pois lognorm"
head(results)
knitr::opts_chunk$set(echo = TRUE)
##
##  This program prints tables of the CI's of beta.
##
results <- NA
setwd('~/overdispersion')
source('readResults9.R')
# where phi==1, population is Poisson
results[which(results$phi == 1),"Population"] <- "Poisson"
header.cols <- c(1,2,3,4,5,14,15)
header.cols <- c(1,2,3,4,5,14,15)
kable(results[,c(header.cols,6,7)],
caption='Coverage of 90% CIs',
digits=2)
y
header.cols <- c(1,2,3,4,5,14,15)
kable(results[,c(header.cols,6,7)],
caption='Coverage of 90% CIs',
digits=2)
library(knitr)
kable(results[,c(header.cols,6,7)],
caption='Coverage of 90% CIs',
digits=2)
library(knitr)
header.cols <- c(1,2,3,4,5,14,15)
kable(results[,c(header.cols,7,8)],
caption='Coverage of 90% CIs',
digits=2)
